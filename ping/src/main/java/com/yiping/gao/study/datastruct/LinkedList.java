package com.yiping.gao.study.datastruct;

/**
 * FileName: LinkedList
 * Author: 高一平
 * Date: 2017/12/19 11:56
 * Description: 线性表的链式存储结构
 * 为了表示每个数据元素ai与其直接后继数据元素ai+1之间的逻辑关系
 * 对数据元素ai来说，除了存储其本身的信息之外，还需存储一个指示其直接后继的信息（即直接后继的存储位置）
 * 我们把存储数据元素的域称为数据域，把存储直接后继位置的域称为指针域
 * 指针域中存储的信息称作指针或链
 * 这两部分信息组成数据元素ai的存储映像，称为结点
 *
 * 【单链表】
 * n个结点（ai的存储映像）链结成一个链表，即为线性表（a1，a2，……，an）的链式存储结构
 * 因为此链表的每个结点中只包含一个指针域，所以叫做【单链表】
 *
 * 链表中第一个结点的存储位置叫做头指针
 * 单链表的第一个结点前附设一个结点，称为头结点。可以不存储任何信息，也可以存储如线性表的长度等附加信息
 *
 * 头指针&头结点异同
 * 头指针：
 * 1、头指针是指链表指向第一个结点的指针，若链表有头结点，则是指向头结点的指针
 * 2、头指针具有标识作用，所以常用头指针冠以链表的名字
 * 3、无论链表是否为空，头指针均不为空。头指针是链表的必要元素
 * 头结点：
 * 1、头结点是为了操作的统一和方便而设立的，放在第一元素的结点之前，其数据域一般无意义（也可以存放链表的长度）
 * 2、有了头结点，对在第一元素结点前插入结点和删除第一结点，其操作与其它结点的操作就统一了
 * 3、头结点不一定是链表的必须要素
 *
 * 假设p是指向线性表第i个元素的指针，则该结点ai的数据域为p-》data，指针域为p-》next
 * 即p-》data=ai；p-》next-》data=ai+1
 *
 * 单链表结构与顺序存储结构
 * 存储分配方式：
 * 1、顺序存储结构用一段连续的存储单元依次存储线性表的数据元素
 * 2、单链表采用链式存储结构，用一组任意的存储单元存放线性表的元素
 * 时间性能：
 * 查找：
 *      顺序存储结构O(1)
 *      单链表O(n)
 * 插入和删除：
 *      顺序存储结构需要平均移动表长一半的元素，时间为O(n)
 *      单链表在线出某位置的指针后，插入和删除时间仅为O(1)
 * 空间性能：
 * 1、顺序存储结构需要预分配存储空间，分大了，浪费，分小了易发生上溢
 * 2、单链表不需要分配存储空间，只要有就可以分配，元素个数也不受限制
 *
 * 【静态链表】用数组描述的链表，还叫做游标实现法
 * 让数组的元素都是由两个数据域组成，data和cur
 * 数据域data，用来存放数据元素
 * 游标cur存放数据元素的后继在数组中的下标
 *
 * 数组第一个和最后一个元素作为特殊元素处理，不存数据
 * 把未使用的数组元素称为备用链表
 * 数组第一个元素，即下标为0的元素的cur就存放备用链表的第一个结点的下标
 * 数组最后一个元素的cur，则存放第一个有数值的元素的下标，当整个链表为空时，则为0^2
 *
 * 静态链表的优缺点
 * 优点：在插入和删除操作时，只需要修改游标，不需要移动元素，从而改进了在顺序存储结构中的插入和删除操所需要移动大量元素的缺点
 * 缺点：1、没有解决连续存储分配带来的表长难以确定的问题
 *       2、失去了顺序存储结构随机存取的特性
 *
 * 【循环链表】
 * 将单链表中终端结点的指针端由空指针改为指向头结点，就使整个单链表形成一个环，这种头尾相接的单链表称为单循环链表，简称循环链表
 *
 * 循环链表通常设一个头结点，这样
 * 单链表判断循环结束为p-》next为空
 * 循环链表判断循环结束为p-》next不等于头结点
 *
 * 【官方LinkedList】
 * 非线程安全
 * 基于环形双向链表
 * get(int index)需要遍历链表，速度慢；
 * iterator()方法中调用了get(int index)，所以速度也慢
 * set(int index, E e)方法中调用了get(int index)，所以速度也慢
 * add方法不需要考虑扩容与数组复制问题，只需创建新对象，再将新对象的前后节点的指针指向重新分配一下就好，速度快
 * remove(Object o)需要遍历链表，但不需要复制元素，只需将所要删除的对象的前后节点的指针指向重新分配一下以及将所要删除的对象的三个属性置空即可，速度快
 * remove(int index)需要遍历链表，但不需要复制元素，只需将所要删除的对象的前后节点的指针指向重新分配一下以及将所要删除的对象的三个属性置空即可，但不常用
 * contain(E)需要遍历链表
 */

public class LinkedList<E> implements List<E>{

    /**
     * 【单链表】
     * 创建单链表的过程就是一个动态生成链表的过程。
     * 即从“空表”的初始状态起，一次建立各元素结点，并逐个插入链表
     * 思路：
     * 1、声明一结点p和计数器变量i
     * 2、初始化一空链表L
     * 3、让L的头结点的指针指向NULL，即建立一个带头结点的单链表
     * 4、循环：
     *      生成一新节点赋值给p
     *      随机生成一数字赋值给p的数据域p-》data
     *      （头插法）
     *      将p插入到头结点与前一新节点之间
     *      （尾插法）
     *      将表尾终端结点的指针指向p
     *      将p定义为表尾终端结点
     */
    public void InitList() {

    }

    public boolean ListEmpty() {
        return false;
    }

    /**
     * 【单链表】思路：
     * 1、声明一结点p和q
     * 2、将第一个结点赋值给p
     * 3、循环：
     *      将下一结点赋值给q
     *      释放p
     *      将q赋值给p
     *
     * @return
     */
    public boolean ClearList() {
        return false;
    }

    /**
     * 【单链表】思路：
     * 1、声明一个结点p指向链表第一个结点，初始化j从1开始
     * 2、当j<i时，就遍历链表，让p的指针向后移动，不断指向下一个结点，j累加1
     * 3、若到链表末尾p为空，则说明第i个元素不存在
     * 4、否则查找成功，返回结点p的数据
     *
     * @param i
     * @return
     */
    public E GetElem(int i) {
        return null;
    }

    public int LocateElem(E e) {
        return 0;
    }

    /**
     * 【单链表】思路：
     * 1、声明一结点p指向链表第一个结点，，初始化j从1开始
     * 2、当j<i时，就遍历链表，让p的指针向后移动，不断指向下一结点，j累加1
     * 3、若到链表末尾p为空，则说明第i个元素不存在
     * 4、否则查找成功，在系统中生成一个空结点s
     * 5、将数据元素e赋值给s-》data
     * 6、单链表的插入标准语句s-》next=p-》next；p-》next=s
     * 7、返回成功
     *
     * @param e 新元素
     * @param i 位置
     * @return
     */
    public int ListInsert(E e, int i) {
        return 0;
    }

    /**
     * 【单链表】思路：
     * 1、声明一结点p指向链表第一个结点，初始化j从1开始
     * 2、当j<i时，就遍历链表，让p的指针向后移动，不断指向下一个结点，j累加1
     * 3、若到链表末尾p为空，则说明第i个元素不存在
     * 4、否则查找成功，将欲删除的结点p-》next赋值给q
     * 5、单链表的删除标准语句p-》next=q-》next
     * 6、将q结点中的数据赋值给e，作为返回
     * 7、释放q结点
     * 8、返回成功
     *
     * @param i 位置
     * @return
     */
    public E ListDelete(int i) {
        return null;
    }

    public int ListLength() {
        return 0;
    }
}
